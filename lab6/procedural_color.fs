// Set the pixel color to an interesting procedural color generated by mixing
// and filtering Perlin noise of different frequencies.
//
// Uniforms:
uniform mat4 view;
uniform mat4 proj;
uniform float animation_seconds;
uniform bool is_moon;
// Inputs:
in vec3 sphere_fs_in;
in vec3 normal_fs_in;
in vec4 pos_fs_in; 
in vec4 view_pos_fs_in; 
// Outputs:
out vec3 color;

// expects: blinn_phong, perlin_noise
void main()
{
  float angle = 2 * M_PI * (animation_seconds / 8.0);
	vec4 light_pos = vec4(2*cos(angle), 1.5, 2*sin(angle), 1);
	light_pos = view * light_pos;

	vec3 n = normalize(normal_fs_in);
	vec3 v = normalize(-view_pos_fs_in.xyz);
	vec3 l = normalize(light_pos.xyz - view_pos_fs_in.xyz);
	float p = 1000;

	 float w = 2.5;
  float k1 = 12;
  float k2 = 8;

    float base = perlin_noise(k2 * sphere_fs_in);
    float layer1 = perlin_noise(2 * k2 * sphere_fs_in) * 0.5;
	float layer2 = 0.3*sin(k1* sphere_fs_in.x + k1 * sphere_fs_in.y);
    float noise_val = base + layer1 + layer2;

	float noise = clamp(noise_val / w, -0.1, 0.1);

	vec3 ka;
	vec3 kd;
	vec3 ks;

	if (is_moon) {
		ka = vec3(0.03, 0.03, 0.03);
		kd = mix(vec3(0.5,  0.5,  0.5), vec3(1,1,1), noise);
		ks = vec3(0.5,  0.5,  0.5);
	} else {
		ka = vec3(0.03, 0.03, 0.03);
		kd = mix(vec3(0.2,  0.2,  1), vec3(0.8,0.8,0.8), noise);
		ks = vec3(0.5,  0.5,  0.5);
	}
	
	color = blinn_phong(ka, kd, ks, p, n, v, l);
}
